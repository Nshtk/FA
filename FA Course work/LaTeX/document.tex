\usepackage[14pt]{extsizes}
\documentclass[a4paper,14pt]{article}
\usepackage{maicoursework}
\usepackage{float}
\makeglossaries

\input{glossary}
%%% Преамбула
\author{Солдатов Вячеслав Алексеевич}
\title{Паттерны проектирования}
\date{\today}
\MAIProfessorName{Романенков Александр Михайлович}
\MAIWorkType{Курсовая работа}
\MAISubject{Фундаментальные алгоритмы}
\MAIGroup{М80-211Б-19}
\begin{document}

\maketitle
\setcounter{page}{2}
\tableofcontents
\clearpage
\clearpage


\section{Описание задания}
\subsection{Вариант №32}
Разработайте приложение для проведения лотереи (например, аналога
Русского лото). Ваше приложение должно обеспечивать генерацию билетов для
очередного тиража лотереи (генератор должен быть реализован посредством
паттерна “фабричный метод”). Количество генерируемых билетов произвольно и
может быть велико (> 20’000’000 шт.). Учтите ситуацию, что не все
сгенерированные билеты могут участвовать в тираже (это типичная ситуация,
которая возникает при неполной реализации билетов к тиражу). Смоделируйте
проведение розыгрыша: на каждом ходе проверяйте, появился ли победитель;
предусмотрите систему выигрышей; предоставьте возможность поиска билетов
по заданным критериям: номеру билета, величине выигрыша, и т. д.. Сохраняйте
информацию о проведенных тиражах для обеспечения поиска данных в
будущем. Реализуйте функционал обработки данных таким образом, чтобы тип
коллекции, в которой будут храниться ваши данные, являлся параметром.
Продемонстрируйте обработку данных с использованием std::forward\_list и
собственной реализации односвязного списка.
\clearpage

\section{Описание решения}

\subsection{Описание алгоритма}
Для решения поставленной задачи программа выполняет следующие действия\newline
\begin{enumerate} 
  \item Открытие файла на запись с проверкой. Если проверка не пройдена, программа завершает свою работу с кодом ошибки, переданным в функцию errCheck\_Main(), которая также выводит информацию для пользователя в соответствии с кодом ошибки.
  \item Передача управления функции clientCode()
  \item Создание генераторов для генерации обьектов типа: БИЛЕТ, ТИРАЖ, ИГРА.
  \item Создание объекта класса ИГРА, передача в конструктор класса следующих параметров: id игры, количество тиражей, количество билетов в каждом тираже, шанс продажи билета.
  \item Создание объектов класса ТИРАЖ внутри конструктора класса ИГРА с помощью генератора, помещение объектов класса ТИРАЖ в односвязный список указателей типа ТИРАЖ - приватное поле класса ИГРА. 
  \item Создание объектов класса БИЛЕТ, внутри конструктора класса ТИРАЖ с помощью генератора, помещение объектов класса БИЛЕТ в односвязный список указателей типа БИЛЕТ - приватное поле класса ТИРАЖ. 
  \item Возвращение управления функции clientCode(), начало взаимодействия с пользователем в формате "ввод операции - вывод данных или особого ответа."
  \item При вводе пользователем операции обработки игры происходит обработка тиража, номер которого указал пользователь, или всех тиражей с помощью функции processGame().
  \item Передача управления функции processLot().
  \item В функции processLot() происходит "пошаговая" обработка билетов по принципу: вынимается бочонок с числом - обрабатывается весь список билетов. Если число на боченке совпадает с числом в одном или нескольких из полей билета, число в билете "зачеркивается".
  \item Выбор победителей посредством проведения 3-х туров. Билет выйгравший в определенном туре помечается особым образом и попадает в список указателей <имя тура>\_tour\_winner\_tickets типа БИЛЕТ - приватное поле класса ИГРА.
  \item Возвращение управления функции processGame(), внутри которой сначала происходит обработка ошибок с помощью функций заголовочного файла error\_check.h, которые могли возникнуть при обработке тиражей в функции processLot.
  \item В функции processGame() происходит вывод всех списков с названиями  <имя тура>\_tour\_winner\_tickets в стандартный поток вывода, таким образом показывая пользователю победившие билеты.
  \item Возвращение управления функции clientCode() вместе с кодом ошибки, обработка ошибок с помощью функций заголовочного файла error\_check.h, блокирование доступа к определенным операциям в завсисмости от кода ошибки.
  \item Следующая итерация взаимодействия с пользователем, в зависимости от введенной пользователем операции производится вывод данных об прошедшей игре в файл, поиск билета по файлу.
  \item Завершение работы с пользователем, очистка памяти.
  \item Возвращение управления функции main() вместе с кодом ошибки, обработка ошибок с помощью функций заголовочного файла error\_check.h, завершение работы программы с помощью функции errCheck\_Main().
\end{enumerate}
\subsection{Описание реализованных сущностей}
Для решения поставленной задачи были реализованы следующие сущности:
\subsubsection{main.cpp}
\begin{center}
   Функция main()
\end{center}
Открывает файл output\_file.txt на запись 
\item Задает seed для случайно генерации чисел в объектах класса ПОЛЕ - приватных объектах класса БИЛЕТ
\item Передает управление функции clientCode()
\item Обрабатывает код ошибки, полученный в качестве возвращаемого значения от функции clientCode(), передавая управление функции  errCheck\_Main().
\subsubsection{client\_code.h}
\begin{center}
   Функция clientCode()
\end{center}
Создает указатели на объекты классов SuperGenerator и Game
\item Осуществляет взаимодействие с пользователем с помощью классической контрукции while(true) и switch(operation). Доступные для пользователя операции: p - основная операция, выявление победителей среди купивших билет, обработка тиражей; о - вывод данных всех по проведенной игре в файл output\_file.txt; s - поиск определенного билета в файле output\_file.txt; с - выход из цикла, завершение взаимодействия с пользователем.
\item Очистка памяти.
\subsubsection{functions.h}
\begin{center}
   Функция foundDuplicate(int8\_t*, int, int)
\end{center}
Поиск дубликатов в массиве, замена дубликата другим значением
\begin{center}
   Функция getValues(int8\_t*)
\end{center}
Заполнение массива размером 2х5 случайными значениями, используется функция foundDuplicate()
\subsubsection{components.h}
Все классы, кроме класса KegBag, описанные в этом заголовочном файле, имеют вроизводные классы с приставкой RusLot в названии
\begin{center}
   Класс KegBag
\end{center}
Задача этого класса - симуляция мешка с бочонками. Количество бочонков задается макросом NUMBER\_OF\_KEGS, специально сделано неизменяемым с пользовательской стороны.Класс имеет метод для доставания бочонка или нескольких бочонков getKegs(vector<unsigned int>&, unsigned int), а также оператор вывода в поток.
\begin{center}
   Абстрактный класс Field
\end{center}
Этот класс содержит указатель на указатель типа unsigned int8\_t, количество строк и столбцов поля билета, имеет перегруженный деструктор для очистки памяти, операторы выгрузки и вставки в поток. Класс Ticket является дружественным к этому классу.
\begin{center}
   Шаблонный абстрактный класс Ticket
\end{center}
Этот класс содержит шаблонный вектор полей производного класса от класса Ticket, а также поля атомарных типов для вывода информации о билете. Имеет метод getStatus() нужный для получения информации о статусе билета (продан, куплен, победил в n-ом туре и т.д.), processTicket(), который "зачеркивает" совпавшие числа в полях билета, имеет операторы вставки и выгрузки из потока. Абстрактный класс Lot и шаблонная функция Ticket<> *searchTickets(Game<, >&, Ticket<>*, int) являются дружественными к этому классу.
\begin{center}
   Шаблонный абстрактный класс Lot
\end{center}
Этот класс хранит список указателей на объекты класса Ticket, объект класса KegBag, оператор выгрузки из потока. Абстрактный шаблонный класс Game является дружественным к этому классу.
\begin{center}
   Шаблонный абстрактный класс Game
\end{center}
Этот класс хранит список указателей на объекты класса Lot, а также три списка указателей на объекты класса Ticket. Класс Game в самом верху иерархии лотереи, имея список класса Lot (тираж). Конструктор класса создает летерию, иерархично создавая объекты классов типа Lot и Ticket. Game имеет методы вывода в стандартный поток списков билетов-победителей printWinners(ListBasicInterface< , Ticket<>*>&), обработки тиража processLot(long int, auto lot) и всей игры processGame(int, unsigned int, int), проведения розыгрыша processTour(unsigned int, auto& lot, ListBasicInterface< , Ticket<>*>&, int, vector<unsigned int>&), вставки в поток.
\subsubsection{generators.h}
В этом файле хранятся абстрактные шаблонные и производные генераторы для всех классов, кроме Field и KegBag. Также здесь определен абстрактный класс SuperGenerator, хранящий указатели на абстрактные шаблонные генераторы.
\subsubsection{err\_check.h}
В этом файле хранятся хранятся функции int errCheck\_Components(int, unsigned int), int errCheck\_ClientCode(int, long int), int errCheck\_Main(int, long int) для обработки ошибок на разных уровнях выполнения программы.
\subsubsection{list\_decorator.h}
\begin{center}
   В этом файле хранится реализация собственного односвязного списка в виде класса List со стандартными для односвязного списка методами и общий для List и forward\_list шаблонный интерфейс в виде класса ListBasicInterface, хранящий контейнер односвязного списка.
\end{center}

\begin{center}
    \subsubsection{Структура билета}
\end{center}
Билет содержит поля:
\begin{enumerate} 
  \item Номер тиража
  \item Номер билета
  \item Статус билета
  \item Вектор, содержащий игровые поля.
\end{enumerate}

\clearpage
\begin{center}
    \subsubsection{Демонстрация работы, входные и выходные данные}
\end{center}


\begin{figure}[H]
  \includegraphics[width=\linewidth]{pictures/1}
  \caption{Пользователь вводит операцию обработки первого и второго тиража билетов, программа обрабатывает тиражи без ошибок.}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pictures/2}
  \caption{Программа выводит в стандартный поток вывода билеты, победившие в первом туре.}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pictures/3}
  \caption{Программа выводит в стандартный поток вывода билеты, победившие в первом туре.}
\end{figure}
\begin{figure}[H]
  \includegraphics[width=\linewidth]{pictures/4}
  \caption{Программа выводит в стандартный поток вывода билеты, победившие во втором туре.}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pictures/5}
  \caption{Программа закончила вывод победивших во втором туре билетов и сообщила, что победителей в третьем туре нет. Пользователь вводит операцию обработки третьего, последнего тиража и операцию вывода данных в файл.}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pictures/6}
  \caption{Пользователь вводит операцию поиска билета и находит билет согласно введенным параметрам.}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pictures/7}
  \caption{Пользователь звершает свою работу с программой, которая отработала без ошибок.}
\end{figure}
\begin{figure}[H]
  \includegraphics[width=\linewidth]{pictures/8}
  \caption{Часть содержания файла output\_file.txt}
\end{figure}
\clearpage

\section{Вывод}
В этой курсовой работе мною были продемонстрированы навыки работы с шаблонными и абстрактными классами, пример проектирования приложения с помощью паттерна "Шаблонный метод". Также был реализован интерфейс для односвязныйх списков с использованием паттерна "Декоратор" и продемонстрирована работа спроектированного приложения.
\newpage

\section{Литература}

\printbibliography

\clearpage

\section{Приложение}
\subsubsection{main.cpp}
\begin{minted}{C++}
#include <iostream>
#include <fstream>
#include <ctime>
#include "generators.h"
#include "client_code.h"

using namespace std;

int main()
{
    int err_code;                                                   // Замена errno.
    ofstream ofp("output_file.txt");
    if(!ofp.is_open())
    {
        err_code=1;
        errCheck_Main(err_code, 0);
    }

    srand(static_cast <unsigned>(time(nullptr)));

    if(clientCode(ofp, err_code))
        err_code=2;
    ofp.close();

    errCheck_Main(err_code, 0);
}

\end{minted}
\subsubsection{client\_code.h}
\begin{minted}{C++}
#ifndef FA_KURS_CLIENT_CODE_H
#define FA_KURS_CLIENT_CODE_H

#include <forward_list>

#define LIST_IMPLEMENTATION forward_list
#define BAD_ACCESS "You cannot access this operation: "

int clientCode(ofstream &fp, int err_code)
{
    SuperGenerator<FieldRusLot, LIST_IMPLEMENTATION> *super_gen = new SuperGeneratorRusLot<LIST_IMPLEMENTATION>();
    Game<FieldRusLot, LIST_IMPLEMENTATION> *game=super_gen->gen_game->getGame(0, 3, 20000, 0.8, *super_gen->gen_lot,
                                                                              *super_gen->gen_tic);
    cout << "Available operations:\n"
            "'p' - enter process mode and id of lot to process. In zero mode id is useless;\n"
            "'o' - print winners;\n"
            "'f' - write processed data to output_file;\n"
            "'s' - search specific tickets in output_file;\n"
            "'c' - finish work and exit program.";
    char operation;
    int process_mode, number;
    bool proceed=true, p_not_blocked=true, s_not_blocked=false, o_f_not_blocked=false;
    while(proceed)
    {
        cout << "\n\nEnter operation:\n";
        cin >> operation;
        switch(operation)
        {
            case 'p':
                if(p_not_blocked)
                {
                    cin >> process_mode >> number;
                    while((err_code = game->processGame(process_mode, number, err_code)) == -1)
                        cin >> process_mode;
                    if(err_code)
                    {
                        err_code=1;
                        p_not_blocked=false;
                        break;
                    }
                    o_f_not_blocked=true;
                }
                else
                    cout << BAD_ACCESS"Last calculation ended with errors.\n";
                break;

            case 'o':
                if(o_f_not_blocked)
                    game->printAllWinners();
                else
                    cout << BAD_ACCESS"Game has not been processed or processing has ended with errors.\n";
                break;

            case 'f':
                if(o_f_not_blocked)
                {
                    fp << *game;
                    s_not_blocked=true;
                    cout << "Done.\n";
                }
                else
                    cout << BAD_ACCESS"Game has not been processed or processing has ended with errors.\n";
                break;

            case 's':
                if(s_not_blocked)
                {
                    if(!searchTickets(*game, super_gen->gen_tic->getTicket(0, 0, -1), err_code))
                        err_code=1;
                }
                else
                    cout << BAD_ACCESS"Processed data has not been written to file.\n";
                break;

            case 'c':
                proceed=false;
                break;

            default:
                cout << "No such operation, try again.\n";
        }
    }
    delete super_gen; delete game;

    return errCheck_ClientCode(err_code, 0);
}

#endif

\end{minted}
\subsubsection{functions.h}
\begin{minted}{C++}
#ifndef FA_KURS_FUNCTIONS_H
#define FA_KURS_FUNCTIONS_H

int foundDuplicate(int8_t *arr, int i, int number)
{
    i++;
    for(int j=0; j<i; j++)
        if(number==arr[j])
            return 1;
    arr[i-1]=number;
    return 0;
}

void getValues(int8_t arr[2][5])
{
    int i, min;
    for(i=0; i<5; i++)
        while(foundDuplicate(arr[0], i, rand() % 9)) {}
    for(i=0; i<5; i++)
    {
        if((min=(arr[0][i]+1)*10-10)==0)
            min=1;
        while(foundDuplicate(arr[1], i, rand() % 10+min)) {}
    }
}

#endif

\end{minted}
\subsubsection{components.h}
\begin{minted}{C++}
#ifndef FA_KURS_COMPONENTS_H
#define FA_KURS_COMPONENTS_H

#include <algorithm>
#include <vector>
#include <cstdint>
#include <random>
#include <chrono>
#include "list_decorator.h"
#include "generators.h"
#include "functions.h"

#define NUMBER_OF_KEGS 90

using namespace std;

template<class T>
class GeneratorTicket;
template <class T, template<class> class L>
class GeneratorLot;

class KegBag
{
private:
    vector<unsigned int> bag;
public:
    KegBag()
    {
        unsigned seed = chrono::system_clock::now().time_since_epoch().count() + rand();          // rand() прибавлен из-за того, что сид практически не меняется в единицу времени.
        for(int i=1; i<NUMBER_OF_KEGS; i++)
            bag.push_back(i);
        shuffle(bag.begin(), bag.end(), default_random_engine(seed));
    }
    void getKegs(vector<unsigned int> &vec, unsigned int amount)
    {
        vec.clear();
        for(int i=0; i<amount; i++)
        {
            vec.push_back(bag.back());
            bag.pop_back();
        }
    }

    friend const ostream& operator<<(ostream &out, const KegBag &keg_bag)
    {
        out << "Remaining kegs in bag:";
        for(auto it : keg_bag.bag)
            out << ' ' << it;
        return out;
    }
};

class Field
{
protected:
    unsigned int row_count;
    unsigned int col_count;
    int8_t **field;
public:
    Field(unsigned int rows, unsigned int cols) : row_count(rows), col_count(cols)
    {
        unsigned int j;
        int8_t field_values_in_row[2][5];

        field=new int8_t *[row_count];
        for(unsigned int i=0; i<row_count; i++)
        {
            field[i]=new int8_t[col_count];
            for(j=0; j<col_count; j++)
                field[i][j] = 0;

            getValues(field_values_in_row);
            for (j = 0; j < 5; j++)
                field[i][field_values_in_row[0][j]] = field_values_in_row[1][j];
        }
    }
    ~Field()
    {
        for(int i=0; i<row_count; i++)
            delete[]field[i];
        delete[]field;
    }
    friend const ostream& operator<< (ostream &out, const Field &fld);
    friend istream& operator>> (istream &in, Field &fld);
    template<class> friend class Ticket;
};

class FieldRusLot : public Field
{
public:
    FieldRusLot() : Field(3, 9) {}
};

const ostream& operator<< (ostream &out, const Field &fld)
{
    for(int i=0; i<fld.row_count; i++)
    {
        for(int j=0; j<fld.col_count; j++)
            out << (int)fld.field[i][j] << ' ';
        out << '\n';
    }
    return out;
}

istream& operator>> (istream &in, Field &fld)
{
    int tmp;
    for(int i=0; i<fld.row_count; i++)
    {
        for(int j=0; j<fld.col_count; j++)
        {
            in >> tmp;
            fld.field[i][j]=tmp;
        }
        in.get(); in.get();
    }
}

template <class T, template<class> class L> class Game;

template<class T>
class Ticket
{
protected:
    unsigned int lot_number, ticket_number, status;
    vector<T> fields;
public:
    Ticket(unsigned int lot_num, unsigned int ticket_num, unsigned int field_count, unsigned int status) :
            lot_number(lot_num), ticket_number(ticket_num),
            fields(field_count), status(status) {}
    ~Ticket()
    {
        fields.clear();
    }
    int getStatus()
    {
        return status;
    }
    int processTicket(vector<unsigned int> &numbers, int vic_type)
    {
        int i, j;
        int counters[3] = {0};                                            // Проверяют строку, поле и билет на зачеркивание всех чисел в строке/поле/всех полях.
        for(auto &fld : fields)
        {
            counters[1]=0;
            for(i=0; i<fld.row_count; i++)
            {
                counters[2]=0;
                for(j=0; j<fld.col_count; j++)
                {
                    for(auto &num : numbers)
                    {
                        if(fld.field[i][j] < 0)
                            counters[2]++;
                        else if (num == fld.field[i][j])
                        {
                            fld.field[i][j]*=-1;
                            counters[2]++;
                            break;
                        }
                    }
                }
                if(counters[2]==5)
                {
                    if(vic_type==1)
                    {
                        status = 2;
                        return 1;
                    }
                    counters[1]++;
                }
            }
            if(counters[1]==3)
            {
                counters[0]++;
                if(vic_type==2)
                {
                    status = 3;
                    return 1;
                }
            }
        }
        if(counters[0]==2 && vic_type==3)
        {
            status = 4;
            return 1;
        }
        return 0;
    }
    friend ostream& operator<< (ostream &out, Ticket<T> &tic)
    {
        out << "Lot series: " << tic.lot_number << '\n';
        out << "Ticket: " << tic.ticket_number << "\n";

        unsigned int field_count=tic.fields.size();
        for(int i=0; i<field_count; i++)
            out << "Field " << i << '\n' << tic.fields[i];

        switch(tic.status)
        {
            case 0:
                out << "UNSOLD";
                break;
            case 1:
                out << "SOLD";
                break;
            case 2:
                out << "1-st TOUR WINNER, SOLD";
                break;
            case 3:
                out << "2-nd TOUR WINNER, SOLD";
                break;
            case 4:
                out << "3-rd TOUR WINNER, SOLD";
                break;
        }
        out << '\n';
        return out;
    }
    friend istream& operator>> (istream &in, Ticket<T> &tic)
    {
        unsigned int size=tic.fields.size();
        char c;

        in.ignore(12);
        in >> tic.lot_number;
        in.ignore(8,' ');
        in >> tic.ticket_number;
        in.get(c);
        for(int i=0; i<size; i++)
        {
            in.ignore(20, '\n');                                          // Пропуск Field.
            in>>tic.fields[i];
        }
        in.get(c);
        switch(c)
        {
            case 'U':
                tic.status = 0;
                break;
            case 'S':
                tic.status = 1;
                break;
            case '1':
                tic.status = 2;
                break;
            case '2':
                tic.status = 3;
                break;
            case '3':
                tic.status = 4;
                break;
        }
        in.ignore(30, '\n');
    }
    template <class C, template<class> class L> friend Ticket<C> *searchTickets(Game<C, L> &game, Ticket<C> *tic, int &err_code);
    template <class, template<class> class> friend class Lot;
};

class TicketRusLot : public Ticket<FieldRusLot>
{
public:
    TicketRusLot(unsigned int lot_num, unsigned int ticket_num, unsigned int status) : Ticket(lot_num, ticket_num, 2, status) {}
};

template <class T, template<class> class L>
class Lot
{
private:
    bool was_processed;
    unsigned int lot_number;
    KegBag keg_bag;
    ListBasicInterface<L, Ticket<T>*> lot_tickets;
public:
    Lot(unsigned int num, unsigned int num_of_tickets, unsigned int sale_chance, GeneratorTicket<T> &gen) : was_processed(false), lot_number(num)
    {
        if(rand()%2 || sale_chance==100)                                                           // Полная или неполная реализация тиража.
            for(unsigned int i=0; i<num_of_tickets; i++)
                lot_tickets.push_front(gen.getTicket(lot_number, i, 1));
        else
            for(unsigned int i = 0; i < num_of_tickets; i++)
                lot_tickets.push_front(gen.getTicket(lot_number, i,(rand()%100)<sale_chance));
    }
    ~Lot()
    {
        lot_tickets.clear();
    }
    template <class, template<class> class> friend class Game;
    friend ostream& operator<< (ostream &out, Lot<T, L> &lot)
    {
        for(auto it = lot.lot_tickets.begin(); it!=lot.lot_tickets.end(); it++)
            out << **it << '\n';
        return out;
    }
};


template <class T, template<class> class L>
class Game
{
private:
    unsigned int game_id;
    unsigned int game_size;
    ListBasicInterface<L, Lot<T, L>*> lot_tickets;
    ListBasicInterface<L, Ticket<T>*> first_tour_winner_tickets;
    ListBasicInterface<L, Ticket<T>*> second_tour_winner_tickets;
    ListBasicInterface<L, Ticket<T>*> third_tour_winner_tickets;

    Game(unsigned int id, unsigned int num_of_lot, unsigned int num_of_tic, float sale_chance, GeneratorLot<T, L> &gen_lot, GeneratorTicket<T> &gen_tic)
            : game_id(id), game_size(num_of_lot)
    {
        sale_chance*=100;
        if(sale_chance<1 || sale_chance>100)
            sale_chance=rand() %100 +1;

        for(int i=0; i<game_size; i++)
            lot_tickets.push_front(gen_lot.getLot(i, num_of_tic, sale_chance, gen_tic));
    }

    void printWinners(ListBasicInterface<L, Ticket<T>*> &winner_tickets)
    {
        if(winner_tickets.empty())
        {
            cout << "No winners!";
            return;
        }
        for(auto it=winner_tickets.begin(); it!=winner_tickets.end(); it++)
            cout << **it <<'\n';
    }
    int processTour(unsigned int n, auto &lot, ListBasicInterface<L, Ticket<T>*> &tour_winner_tickets, int victory_type, vector<unsigned int> &kegs)
    {
        for(int i=0; i<n; i++)
        {
            (*lot)->keg_bag.getKegs(kegs, 1);
            for (auto tic : (*lot)->lot_tickets)
                if (tic->getStatus() == 1)
                    if (tic->processTicket(kegs, victory_type))
                        tour_winner_tickets.push_front(tic);
        }
    }
public:
    ~Game()
    {
        lot_tickets.clear();
        first_tour_winner_tickets.clear();
        second_tour_winner_tickets.clear();
        third_tour_winner_tickets.clear();
    };
    int processLot(long int lot_to_process, auto lot)
    {
        if(lot==lot_tickets.end())                                          // Проверка на нахождение номера тиража в списке тиражей.
        {
            auto lt=lot_tickets.begin();
            for (; lt!=lot_tickets.end(); lt++)
            {
                if (lot_to_process == (*lt)->lot_number)
                {
                    lot_to_process = -1;
                    break;
                }
            }
            if(lot_to_process != -1)
                return 1;
            lot=lt;
        }
        if((*lot)->was_processed)
            return 2;

        vector<unsigned int> kegs;
        (*lot)->keg_bag.getKegs(kegs, 5);
        cout << "\nProcessing lot with id " << (*lot)->lot_number << "\nProcessing first tour...\n";
        for(auto tic : (*lot)->lot_tickets)
            if(tic->getStatus()==1)
                tic->processTicket(kegs, 1);
        processTour(10, lot, first_tour_winner_tickets, 1, kegs);           // Первый параметр - количество вынимаемых бочонков в туре.
        cout << "Processing second tour...\n";
        processTour(30, lot, second_tour_winner_tickets, 2, kegs);
        cout << "Processing third tour...\n";
        processTour(15, lot, third_tour_winner_tickets, 3, kegs);

        (*lot)->was_processed=true;
        cout << (*lot)->keg_bag;

        return 0;
    }
    int processGame(int process_mode, unsigned int number, int &err_code)
    {
        switch(process_mode)
        {
            case 0:
                for(auto lot = lot_tickets.begin(); lot != lot_tickets.end(); lot++)
                    if((err_code=processLot((*lot)->lot_number, lot)))
                        errCheck_Components(err_code, (*lot)->lot_number);
                break;
            case 1:
                if((err_code=processLot(number, lot_tickets.end())))
                    errCheck_Components(err_code, number);
                break;
            default:
                cout << "\nNo such mode, try again.";
                return -1;
        }
        return err_code;
    }
    void printAllWinners()
    {
        cout << "\n\nFirst tour winners:\n";
        printWinners(first_tour_winner_tickets);
        cout << "\nSecond tour winners:\n";
        printWinners(second_tour_winner_tickets);
        cout << "\nThird tour winners:\n";
        printWinners(third_tour_winner_tickets);
    }

    template <class, template<class> class> friend class GeneratorGameRusLot;
    friend ostream& operator<< (ostream &out, Game<T, L> &game)
    {
        out << "Game ID: " << game.game_id << "\n\n";
        for(auto it=game.lot_tickets.begin(); it!=game.lot_tickets.end(); it++)
            out << **it;
        return out;
    }
};

template <class C, template<class> class L>
Ticket<C> *searchTickets(Game<C, L> &game, Ticket<C> *tic, int &err_code)           // По обработке ошибок ипринципу работы (не в бесконечном цикле) предполагается, что функция
                                                                                    // должна использоваться для работы с компонентами, не для пользователя.
{
    ifstream fp("output_file.txt");
    if(!fp.is_open())
    {
        err_code=1;
        errCheck_Main(err_code, 0);
    }
    fp.ignore(10,'\n');                                                    // Пропуск Game id.
    fp.get();

    int criteria[3], initial_value=0, count_of_matching;
    cout << "\nEnter lot number, ticket number, status to find ticket.\n"
            "If you enter a negative number for criteria, this criteria will not be taken into consideration when searching."
            "\nIn that case first matching ticket will be returned.\n";
    cin >> criteria[0] >> criteria[1] >> criteria[2];
    for(int i : criteria)
        if(i<0)
            initial_value++;
    do
    {
        count_of_matching=initial_value;
        fp >> *tic;
        if(tic->lot_number==criteria[0] && criteria[0]>-1)
            count_of_matching++;
        if(tic->ticket_number==criteria[1] && criteria[1]>-1)
            count_of_matching++;
        if(tic->status==criteria[2] && criteria[2]>-1)
            count_of_matching++;
        if(count_of_matching==3)
        {
            cout << '\n' << *tic;
            fp.close();
            return tic;
        }
    }
    while(fp.get()!=EOF);

    fp.close();
    cout << "Ticket not found.\n";
    return nullptr;
}
#endif

\end{minted}
\subsubsection{generators.h}
\begin{minted}{C++}
#ifndef FA_KURS_GENERATORS_H
#define FA_KURS_GENERATORS_H

#include "error_check.h"
#include "components.h"

template<class T>
class GeneratorTicket
{
public:
    virtual Ticket<T> *getTicket(unsigned int lot_num, unsigned int ticket_num, unsigned int status) const = 0;
    template <class, template<class> class> friend class Lot;
};

class GeneratorTicketRusLot : public GeneratorTicket<FieldRusLot>
{
public:
    Ticket<FieldRusLot> *getTicket(unsigned int lot_num, unsigned int ticket_num, unsigned int status) const override
    {
        return new TicketRusLot(lot_num, ticket_num, status);
    }
};

template <class T, template<class> class L>
class GeneratorLot
{
public:
    virtual Lot<T, L> *getLot(unsigned int num, unsigned int num_of_tickets, unsigned int sale_chance, GeneratorTicket<T> &gen) const=0;
};

template <class T, template<class> class L>
class GeneratorLotRusLot : public GeneratorLot<FieldRusLot, L>
{
public:
    Lot<FieldRusLot, L> *getLot(unsigned int num, unsigned int num_of_tickets, unsigned int sale_chance, GeneratorTicket<T> &gen) const override
    {
        return new Lot<FieldRusLot, L>(num, num_of_tickets, sale_chance, gen);
    }
};

template <class T, template<class> class L>
class GeneratorGame
{
public:
    virtual Game<T, L> *getGame(unsigned int id, unsigned int num_of_lot, unsigned int num_of_tic, float sale_chance,
                                GeneratorLot<T, L> &gen_lot, GeneratorTicket<T> &gen_tic) const=0;
};

template <class T, template<class> class L>
class GeneratorGameRusLot : public GeneratorGame<FieldRusLot, L>
{
public:
    Game<FieldRusLot, L> *getGame(unsigned int id, unsigned int num_of_lot, unsigned int num_of_tic, float sale_chance,
                                  GeneratorLot<T, L> &gen_lot, GeneratorTicket<T> &gen_tic) const override
    {
        return new Game<FieldRusLot, L>(id, num_of_lot, num_of_tic, sale_chance, gen_lot, gen_tic);
    };
};

template <class T, template<class> class L>
class SuperGenerator
{
public:
    GeneratorGame<T, L> *gen_game;
    GeneratorLot<T, L> *gen_lot;
    GeneratorTicket<T> *gen_tic;
    SuperGenerator(GeneratorGame<T, L> *gen_one, GeneratorLot<T, L> *gen_two, GeneratorTicket<T> *gen_three) : gen_game(gen_one), gen_lot(gen_two),
                                                                                                               gen_tic(gen_three){}
    ~SuperGenerator()
    {
        delete gen_game;
        delete gen_lot;
        delete gen_tic;
    }
};

template <template<class> class L>
class SuperGeneratorRusLot : public SuperGenerator<FieldRusLot, L>
{
public:
    SuperGeneratorRusLot() : SuperGenerator<FieldRusLot, L>::SuperGenerator(new GeneratorGameRusLot<FieldRusLot, L>(), new GeneratorLotRusLot<FieldRusLot, L>(),
                                                                            new GeneratorTicketRusLot()) {}
};

#endif
\end{minted}
\subsubsection{error\_check.h}
\begin{minted}{C++}
#ifndef FA_KURS_ERROR_CHECK_H
#define FA_KURS_ERROR_CHECK_H

#define NON_CRITICAL "\nNON CRITICAL: "
#define CRITICAL     "\nCRITICAL: "

using namespace std;

int errCheck_Components(int err_code, unsigned int additional_information)          // Можно было упаковать в классы, но, по-моему, лучше так.
{
    switch(err_code)
    {
        case 1:
            cerr << NON_CRITICAL"Unable to find Lot with id " << additional_information << " in Game!\nProcessing of this lot will not begin.\n\n";
            break;
        case 2:
            cerr << NON_CRITICAL"Lot with id " << additional_information << " has been already processed.\nReprocessing is prohibited\n\n";
            break;
    }
}

int errCheck_ClientCode(int err_code, long int additional_information)
{
    switch(err_code)
    {
        case 1:
            cerr << NON_CRITICAL"Game processing operation ended with errors.\n\n";
            break;
        case 2:
            cerr << NON_CRITICAL"Search operation has returned nullptr.\n\n";
            break;
    }
    if(err_code)
        return 2;
    return 0;
}

int errCheck_Main(int err_code, long int additional_information)
{
    switch(err_code)
    {
        case 1:
            cerr << CRITICAL"Failed to open output file.";              // Обьекты, наследуемые от класса исключений, не используются.
            exit(1);
        case 2:
            cerr << NON_CRITICAL"Program has ended with some errors.";
            exit(2);
        default:
            exit(0);
    }
}

#endif

\end{minted}
\subsubsection{list\_decorator.h}
\begin{minted}{C++}
#ifndef FA_KURS_LIST_DECORATOR_H
#define FA_KURS_LIST_DECORATOR_H

template <class T>
struct Node
{
    T data;
    Node *next;
};

template <class T>
class List
{
private:
    Node<T> *head;
    Node<T> *temp;
public:
    List()
    {
        head=nullptr;
    }

    bool empty() const
    {
        return (head==nullptr);
    }
    void push_front(T data)
    {
        temp = new Node<T>;
        temp->data = data;
        if(empty())
            temp->next = nullptr;
        else
            temp->next = head;
        head = temp;
    }
    bool pop_front(T data)
    {
        temp = head;
        Node<T> *prev;
        while(temp->next != nullptr && temp->data != data)
        {
            prev = temp;
            temp = temp->next;
        }
        if(temp->data == data)
        {
            prev->next = temp->next;
            delete temp;
            return true;
        }
        return false;
    }
    void clear()
    {
        if(empty())
            return;
        for(typename List<T>::iterator it=begin(); it!=end(); it++)
            delete *it;
    }

    class iterator
    {
    friend class List;
    private:
        const Node<T>* current;
    public:
        iterator() : current(nullptr) {}

        iterator(const Node<T>* pNode) noexcept : current(pNode) {}
        iterator& operator=(Node<T>* node)
        {
            this->current = node;
            return *this;
        }
        iterator& operator++()
        {
            if(current)
                current = current->next;
            return *this;
        }
        iterator operator++(int)
        {
            iterator iterator=*this;
            ++*this;
            return iterator;
        }
        bool operator==(const iterator& it)
        {
            return current == it.current;
        }
        bool operator!=(const iterator& it)
        {
            return current != it.current;
        }
        T operator*()
        {
            return current->data;
        }
    };
    iterator begin() const
    {
        return iterator(head);
    }
    iterator end() const
    {
        return iterator(nullptr);
    }
};

template<template<typename> class Container, typename T>
class ListBasicInterface
{
private:
    Container<T> lst;
public:
    ListBasicInterface() = default;
    typename Container<T>::iterator begin()
    {
        return lst.begin();
    }
    typename Container<T>::iterator end()
    {
        return lst.end();
    }
    bool empty() const
    {
        return lst.empty();
    }
    void push_front(const T &data)
    {
        lst.push_front(data);
    }
    void pop_front()
    {
        lst.pop_front();
    }
    void clear()
    {
        lst.clear();
    }
};

#endif
\end{minted}
\cite{knuth-fa}
\cite{knuth-acp}
\cite{knuthwebsite}
\printglossaries

\clearpage

\end{document}